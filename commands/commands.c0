#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <unistd.h>
#include <string.h>

#include "../state/state.h"
#include "../helpers/helpers.h"
#include "../image/image.h"
#include "../plot/plot.h"

// Check if a string is a valid command name
int iscommand(char* text) {
	char* commands[] = {
		"randomstate", "enumerate",
		"simulate",
		"collapse", "min", "max",
		"write", "print", "render", "table",
		"quit",
		"plot"
	};
	for (int i=0; i<12; i++) {
		if (strcmp(text, commands[i]) == 0) {
			return 1;
		}
	}
	return 0;
}

// Execute a command string, writing to stdout and the provided log file
void process_command(char* cmd, FILE* log) {
	char* token = strtok(cmd, " ");
	char* command;
	char* option;
	char optionc = '\0';

	// could this be a single [void] pointer?
	void** selection;
	void** set_selection;

	char* selection_type;

	char* opt;
	int opt_shape[2] = {30, 30};
	int opt_num = 1;
	int opt_iterations = 100;
	int opt_print = 0;
	int opt_unicode = 1;
	char* opt_color = "age";

	int complete = 0;

	// Handle command input
	printx(0, "Processing command...\n");
	do {
		if (token != NULL) {
			token[strcspn(token, "\n")] = 0;
		}
		printx(1, "Handling token [%s]\n", token);

		if (token == NULL) {
			if (optionc == 'p') {
				opt_print = 1;
			}
		}

		if (token == NULL || streq(token, ">")) {
			printx(2, "Executing command %s\n", command);
			if (command == NULL) {
				printx(2, "No command set\n");
			}

			if (streq(command, "randomstate")) {
				{{randomstate_cmd}}
			}
			// TODO: exploit symmetries and pattern components for more compact storage/representation?
			else if (streq(command, "enumerate")) {
				{{enumerate_cmd}}
			}
			else if (streq(command, "write")) {
				{{write_cmd}}
			}
			else if (streq(command, "print")) {
				{{print_cmd}}
			}
			else if (streq(command, "render")) {
				{{render_cmd}}
			}
			else if (streq(command, "table")) {
				if (streq(selection_type, "simulation")) {
					sim_data(*((simulation*) selection));
				}
			}
			else if (streq(command, "simulate")) {
				{{simulate_cmd}}
			}
			else if (streq(command, "collapse")) {
				printx(2, "Collapsing simulation(s)\n");
				if (streq(selection_type, "simulation_set")) {
					selection = calloc(opt_num, sizeof(state));
					for (int j=0; j<opt_num; j++) {
						//simulation sim = simset_selection[j];
						simulation* sim = selection[j];
						printx(2, "Getting state at index %i\n", sim -> time);
						// should this account for the size of a state struct?
						selection[j] = (sim -> states) + (sim -> time) - 2;
					}
					selection_type = "state_set";
				}
				else if (streq(selection_type, "simulation")) {
					simulation* sim = *selection;
					*selection = (sim -> states) + (sim -> time) - 2;
				}
				else {
					printx(2, "Command not supported for this data type\n");
				}
			}
			else if (streq(command, "min")) {
				printx(2, "Reducing to minimum\n");
				if (streq(selection_type, "state_set")) {
					selection_type = "state";
					if (streq(opt, "population")) {
						// TODO
						*selection = min_population(*selection, opt_num);
					}
				}
			}
			else if (streq(command, "max")) {
				printx(2, "Reducing to maximum\n");
				if (streq(selection_type, "state_set")) {
					selection_type = "state";
					if (streq(opt, "population")) {
						// TODO
						*selection = max_population(*selection, opt_num);
					}
				}
			}
			else if (streq(command, "plot")) {
				plot(&selection, "state");
			}
			else if (streq(command, "repeat")) {

			}
			else if (streq(command, "quit")) {
				printx(2, "Exiting\n");
				exit(1);
			}
			else {
				printx(2, "Command not recognized\n");
				complete = 1;
				exit(1);
			}

			if (token == NULL) {
				complete = 1;
			}
		}
		else if (iscommand(token)) {
			command = strdup(token);
			command[strcspn(command, "\n")] = 0;
			printx(2, "Found command %s \n", command);
		}
		else if (token[0] == '-') {
			optionc = token[1];
		}
		else if (optionc != '\0') {
			printx(2, "Received option [-%c] with value %s \n", optionc, token);
			switch (optionc) {
				case 'n': {
					opt_num = atoi(token);
					optionc = '\0';
					break;
				}
				case 'i': {
					opt_iterations = atoi(token);
					optionc = '\0';
					break;
				}
				case 'p': {
					opt_print = 1;
					break;
				}
				case 'u': { opt_unicode = 1; break; }
				case 'c': { opt_color = token; break; }
			}
		}
		else {
			printx(2, "Found unlabeled option\n");
			opt = (char*) strdup(token);
			opt[strcspn(opt, "\n")] = 0;
		}

		printx(2, "getting next token...\n");
		token = strtok(NULL, " ");
		usleep(200000);
	} while (!complete);
}
